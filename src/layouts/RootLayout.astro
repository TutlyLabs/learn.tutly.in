---
import "@/styles/globals.css";
import { ViewTransitions } from "astro:transitions";
import { AppSidebar } from "@/components/sidebar/AppSidebar";
import { AppHeader } from "@/components/sidebar/AppHeader";
import { Toaster } from "react-hot-toast";
import { Toaster as SonnerToaster } from "@/components/ui/sonner";
import { Toaster as ShadcnToaster } from "@/components/ui/toaster";
import Crisp from "@/components/Crisp";
import { RefreshCw } from "lucide-react";
import { getVersion } from "@/lib/version";

interface Props {
  title?: string;
  forceClose?: boolean;
}

const { title = "Tutly", forceClose = false } = Astro.props;

const pathname = Astro.url.pathname;
const user = Astro.locals.user!;
const organization = Astro.locals.organization!;

// @ts-ignore
globalThis.pathname = pathname;

const version = getVersion();
---

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <ViewTransitions />
    <script is:inline>
      const getTheme = () => {
        if (typeof localStorage !== "undefined" && localStorage.getItem("theme")) {
          return localStorage.getItem("theme");
        }
        if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
          return "dark";
        }
        return "light";
      };

      const theme = getTheme();
      document.documentElement.classList[theme === "dark" ? "add" : "remove"]("dark");

      document.addEventListener("astro:after-swap", () => {
        document.documentElement.classList[getTheme() === "dark" ? "add" : "remove"]("dark");
      });
    </script>
    <meta name="theme-color" content="#ffffff" />
    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/manifest.webmanifest" />
  </head>
  <body>
    <div class="loader" transition:persist="loader">
      <div class="loader-bar"></div>
      <div class="loader-shimmer"></div>
    </div>
    <Toaster client:load />
    {
      user && (
        <div class="flex min-h-screen">
          <div class="relative">
            <AppSidebar client:load user={user} pathname={pathname} forceClose={forceClose} />
            <div class="absolute bottom-2 left-0 z-[999] right-0 flex items-center justify-center gap-1.5 px-2 text-xs text-muted-foreground">
              <span>{version}</span>
              <button
                id="checkUpdate"
                class="inline-flex items-center gap-1 rounded-md px-1.5 py-0.5 hover:bg-muted"
                title="Check for updates"
              >
                <RefreshCw className="h-3 w-3 transition-transform" />
              </button>
            </div>
          </div>
          <main class="w-full">
            <AppHeader client:load user={user} pathname={pathname} />
            <div class="p-4">
              <slot />
            </div>
          </main>
        </div>
      )
    }
    <SonnerToaster client:load />
    <ShadcnToaster client:load />
    <Crisp client:only user={user} organization={organization} />
    <script>
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", async () => {
          try {
            const registration = await navigator.serviceWorker.register("/service-worker.js", {
              scope: "/",
            });

            registration.addEventListener("updatefound", () => {
              const newWorker = registration.installing;
              if (newWorker) {
                newWorker.addEventListener("statechange", () => {
                  if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
                    if (confirm("New version available! Would you like to update?")) {
                      newWorker.postMessage({ type: "SKIP_WAITING" });
                      window.location.reload();
                    }
                  }
                });
              }
            });

            console.log("Service Worker registered successfully:", registration.scope);
          } catch (error) {
            console.error("Service Worker registration failed:", error);
          }
        });

        let refreshing = false;
        navigator.serviceWorker.addEventListener("controllerchange", () => {
          if (!refreshing) {
            refreshing = true;
            window.location.reload();
          }
        });
      }

      const checkUpdateBtn = document.getElementById("checkUpdate");
      const refreshIcon = checkUpdateBtn?.querySelector("svg");

      if (checkUpdateBtn) {
        checkUpdateBtn.addEventListener("click", async () => {
          if ("serviceWorker" in navigator) {
            refreshIcon?.classList.add("animate-spin");
            try {
              const registration = await navigator.serviceWorker.ready;
              await registration.update();
              alert("Successfully checked for updates");
            } catch (error) {
              alert("Failed to check for updates");
              console.error("Update check failed:", error);
            } finally {
              setTimeout(() => {
                refreshIcon?.classList.remove("animate-spin");
              }, 1000);
            }
          } else {
            alert("Service Worker is not supported in this browser");
          }
        });
      }
    </script>
  </body>
</html>

<style>
  .loader {
    position: fixed;
    top: 0;
    left: 0;
    z-index: 9999;
    width: 100%;
    height: 3px;
    pointer-events: none;
  }

  .loader-bar {
    position: absolute;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent 0%, hsl(var(--primary)) 50%, transparent 100%);
    transform: translateX(-100%);
    animation: none;
  }

  .loader-shimmer {
    position: absolute;
    top: 0;
    left: 0;
    width: 50%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
    transform: translateX(-100%);
    animation: none;
  }

  .loader.loading .loader-bar {
    animation: loading-bar 1s ease-in-out infinite;
  }

  .loader.loading .loader-shimmer {
    animation: loading-shimmer 1s ease-in-out infinite;
  }

  @keyframes loading-bar {
    0% {
      transform: translateX(-100%);
    }
    50% {
      transform: translateX(0);
    }
    100% {
      transform: translateX(100%);
    }
  }

  @keyframes loading-shimmer {
    0% {
      transform: translateX(-100%);
    }
    100% {
      transform: translateX(200%);
    }
  }

  :root {
    --logo-size: 32px;
  }

  [data-logo] {
    width: var(--logo-size);
    height: var(--logo-size);
    border-radius: 50%;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  [data-logo] img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
</style>

<script>
  let loader: HTMLElement | null = null;
  let loadingTimeout: number;

  document.addEventListener("astro:before-preparation", (event) => {
    if (!loader) {
      loader = document.querySelector(".loader");
    }

    const originalLoader = event.loader;
    event.loader = async function () {
      if (loadingTimeout) {
        clearTimeout(loadingTimeout);
      }

      loader!.classList.add("loading");

      const startTime = performance.now();
      await originalLoader();
      const loadTime = performance.now() - startTime;

      const remainingTime = Math.max(0, 400 - loadTime);
      await new Promise((resolve) => {
        loadingTimeout = Number(
          setTimeout(() => {
            loader!.classList.remove("loading");
            resolve(null);
          }, remainingTime)
        );
      });
    };
  });
</script>

<script is:inline define:vars={{ user }}>
  // @ts-nocheck
  !(function (t, e) {
    var o, n, p, r;
    e.__SV ||
      ((window.posthog = e),
      (e._i = []),
      (e.init = function (i, s, a) {
        function g(t, e) {
          var o = e.split(".");
          2 == o.length && ((t = t[o[0]]), (e = o[1])),
            (t[e] = function () {
              t.push([e].concat(Array.prototype.slice.call(arguments, 0)));
            });
        }
        ((p = t.createElement("script")).type = "text/javascript"),
          (p.crossOrigin = "anonymous"),
          (p.async = !0),
          (p.src =
            s.api_host.replace(".i.posthog.com", "-assets.i.posthog.com") + "/static/array.js"),
          (r = t.getElementsByTagName("script")[0]).parentNode.insertBefore(p, r);
        var u = e;
        for (
          void 0 !== a ? (u = e[a] = []) : (a = "posthog"),
            u.people = u.people || [],
            u.toString = function (t) {
              var e = "posthog";
              return "posthog" !== a && (e += "." + a), t || (e += " (stub)"), e;
            },
            u.people.toString = function () {
              return u.toString(1) + ".people (stub)";
            },
            o =
              "init capture register register_once register_for_session unregister unregister_for_session getFeatureFlag getFeatureFlagPayload isFeatureEnabled reloadFeatureFlags updateEarlyAccessFeatureEnrollment getEarlyAccessFeatures on onFeatureFlags onSessionId getSurveys getActiveMatchingSurveys renderSurvey canRenderSurvey getNextSurveyStep identify setPersonProperties group resetGroups setPersonPropertiesForFlags resetPersonPropertiesForFlags setGroupPropertiesForFlags resetGroupPropertiesForFlags reset get_distinct_id getGroups get_session_id get_session_replay_url alias set_config startSessionRecording stopSessionRecording sessionRecordingStarted captureException loadToolbar get_property getSessionProperty createPersonProfile opt_in_capturing opt_out_capturing has_opted_in_capturing has_opted_out_capturing clear_opt_in_out_capturing debug".split(
                " "
              ),
            n = 0;
          n < o.length;
          n++
        )
          g(u, o[n]);
        e._i.push([i, s, a]);
      }),
      (e.__SV = 1));
  })(document, window.posthog || []);
  posthog.init("phc_fkSt1fQ3v4zrEcSB1TWZMHGA5B0Q0hAB70JlZcINrMU", {
    api_host: "https://us.i.posthog.com",
    person_profiles: "identified_only",
  });
  if (user) {
    posthog.identify(user.id, {
      name: user.name,
      email: user.email,
      role: user.role,
    });
  }
</script>
